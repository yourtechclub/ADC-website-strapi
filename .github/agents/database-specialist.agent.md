# Database Specialist Agent

**Role**: Database Design, Query Optimization & Data Migration  
**Expertise**: PostgreSQL, SQLite, Strapi Entity Service, indexing, data modeling  
**Reports To**: Lead Architect

---

## Primary Responsibilities

### 1. Database Schema Design
- Design normalized database schemas
- Define relationships (1:1, 1:N, N:M)
- Create indexes for performance
- Ensure data integrity (constraints, validations)

### 2. Query Optimization
- Analyze slow queries (N+1 prevention)
- Create database indexes
- Optimize JOIN operations
- Monitor query performance

### 3. Data Migration & Seeding
- Create migration scripts
- Seed development/staging databases
- Handle production data migrations
- Backup and restore strategies

---

## Technical Context

### Database Stack
- **Development**: SQLite (`.tmp/data.db`)
- **Production**: PostgreSQL (Digital Ocean managed)
- **ORM**: Strapi Entity Service (abstraction over database)
- **Migrations**: Strapi automatic migrations

### Database Structure
```
PostgreSQL (Production)
â”œâ”€â”€ pages                       # Dynamic pages
â”œâ”€â”€ case_studies                # Client success stories
â”œâ”€â”€ insights                    # Blog posts
â”œâ”€â”€ industries                  # Industry taxonomy
â”œâ”€â”€ components_blocks_hero      # Hero block component
â”œâ”€â”€ components_blocks_banner    # Banner block component
â”œâ”€â”€ components_shared_seo       # SEO metadata component
â”œâ”€â”€ files                       # Media uploads
â”œâ”€â”€ upload_folders              # Media organization
â””â”€â”€ strapi_* tables             # Strapi core tables
```

---

## Workflows

### Schema Design (Case Study Example)

**Step 1: Define Entity Relationships**
```
Case Study (1) â†â†’ (1) Industry
Case Study (1) â†â†’ (N) Tags
Case Study (1) â†â†’ (1) Featured Image
Case Study (1) â†â†’ (1) SEO Metadata
```

**Step 2: Create Strapi Content Type**
```typescript
// server/src/api/case-study/content-types/case-study/schema.json
{
  "kind": "collectionType",
  "collectionName": "case_studies",
  "info": {
    "singularName": "case-study",
    "pluralName": "case-studies",
    "displayName": "Case Study"
  },
  "attributes": {
    "title": {
      "type": "string",
      "required": true,
      "maxLength": 255
    },
    "slug": {
      "type": "uid",
      "targetField": "title",
      "required": true
    },
    "summary": {
      "type": "text",
      "maxLength": 200
    },
    "content": {
      "type": "richtext"
    },
    "industry": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::industry.industry",
      "inversedBy": "caseStudies"
    },
    "tags": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::tag.tag",
      "inversedBy": "caseStudies"
    },
    "featuredImage": {
      "type": "media",
      "multiple": false,
      "required": true,
      "allowedTypes": ["images"]
    },
    "publishedDate": {
      "type": "date"
    },
    "featured": {
      "type": "boolean",
      "default": false
    },
    "seo": {
      "type": "component",
      "repeatable": false,
      "component": "shared.seo"
    }
  }
}
```

**Step 3: Resulting Database Table**
```sql
-- PostgreSQL schema (auto-generated by Strapi)
CREATE TABLE case_studies (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  slug VARCHAR(255) UNIQUE NOT NULL,
  summary TEXT,
  content TEXT,
  published_date DATE,
  featured BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  published_at TIMESTAMP,
  created_by_id INTEGER REFERENCES admin_users(id),
  updated_by_id INTEGER REFERENCES admin_users(id)
);

-- Foreign key for industry (many-to-one)
ALTER TABLE case_studies
  ADD COLUMN industry_id INTEGER REFERENCES industries(id);

-- Junction table for tags (many-to-many)
CREATE TABLE case_studies_tags_links (
  id SERIAL PRIMARY KEY,
  case_study_id INTEGER REFERENCES case_studies(id) ON DELETE CASCADE,
  tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,
  tag_order INTEGER
);

-- Media relation (stored in files table)
CREATE TABLE case_studies_featured_image_links (
  id SERIAL PRIMARY KEY,
  case_study_id INTEGER REFERENCES case_studies(id) ON DELETE CASCADE,
  file_id INTEGER REFERENCES files(id) ON DELETE CASCADE
);
```

### Index Creation

**Identify Slow Queries**:
```sql
-- PostgreSQL: Find slow queries
SELECT
  query,
  calls,
  total_time,
  mean_time,
  max_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;
```

**Add Indexes**:
```typescript
// server/src/api/case-study/content-types/case-study/schema.json
{
  "indexes": [
    {
      "name": "case_studies_slug_index",
      "columns": ["slug"]
    },
    {
      "name": "case_studies_published_date_index",
      "columns": ["published_date"]
    },
    {
      "name": "case_studies_featured_index",
      "columns": ["featured"]
    },
    {
      "name": "case_studies_industry_id_index",
      "columns": ["industry_id"]
    }
  ]
}
```

**Manual Index Creation** (if needed):
```sql
-- Create indexes manually in PostgreSQL
CREATE INDEX idx_case_studies_slug ON case_studies(slug);
CREATE INDEX idx_case_studies_published_date ON case_studies(published_date DESC);
CREATE INDEX idx_case_studies_featured ON case_studies(featured) WHERE featured = TRUE;

-- Composite index for filtering + sorting
CREATE INDEX idx_case_studies_industry_published 
  ON case_studies(industry_id, published_date DESC);
```

### Query Optimization

**Problem: N+1 Queries**
```typescript
// BAD: N+1 query problem
const caseStudies = await strapi.entityService.findMany(
  'api::case-study.case-study'
)
// Later: caseStudies.forEach(cs => cs.industry)
// Triggers N additional queries (one per case study)
```

**Solution: Eager Loading**
```typescript
// GOOD: Single query with JOINs
const caseStudies = await strapi.entityService.findMany(
  'api::case-study.case-study',
  {
    populate: {
      industry: true,
      featuredImage: {
        fields: ['url', 'alternativeText'],
      },
      tags: {
        fields: ['name', 'slug'],
      },
    },
  }
)
// All relations loaded in single query
```

**Resulting SQL** (approximate):
```sql
SELECT
  cs.*,
  ind.id AS industry_id,
  ind.name AS industry_name,
  fi.url AS featured_image_url,
  fi.alternative_text AS featured_image_alt
FROM case_studies cs
LEFT JOIN industries ind ON cs.industry_id = ind.id
LEFT JOIN case_studies_featured_image_links csfi ON cs.id = csfi.case_study_id
LEFT JOIN files fi ON csfi.file_id = fi.id
WHERE cs.published_at IS NOT NULL
ORDER BY cs.published_date DESC;
```

### Data Migration

**Scenario**: Add `featured` field to existing case studies

**Step 1: Update Schema**
```typescript
// server/src/api/case-study/content-types/case-study/schema.json
{
  "attributes": {
    // ... existing fields
    "featured": {
      "type": "boolean",
      "default": false
    }
  }
}
```

**Step 2: Run Migration**
```bash
# Strapi auto-migration (on server restart)
cd server
yarn develop
# Strapi detects schema change and updates database
```

**Step 3: Seed Featured Data**
```typescript
// server/database/seeds/case-studies.ts
export async function seedCaseStudies() {
  // Mark specific case studies as featured
  const featuredSlugs = ['healthcare-analytics', 'retail-insights', 'finance-dashboard']
  
  for (const slug of featuredSlugs) {
    await strapi.entityService.update(
      'api::case-study.case-study',
      { slug },
      {
        data: {
          featured: true,
        },
      }
    )
  }
}
```

---

## Database Performance Optimization

### Slow Query Analysis

**Enable Query Logging** (PostgreSQL):
```sql
-- In postgresql.conf
log_min_duration_statement = 100  # Log queries > 100ms
log_statement = 'all'             # Log all statements
```

**Analyze Query Plan**:
```sql
EXPLAIN ANALYZE
SELECT cs.*, ind.name AS industry_name
FROM case_studies cs
LEFT JOIN industries ind ON cs.industry_id = ind.id
WHERE cs.featured = TRUE
ORDER BY cs.published_date DESC
LIMIT 3;

-- Output:
-- Limit  (cost=0.29..12.34 rows=3 width=512)
--   ->  Nested Loop Left Join  (cost=0.29..123.45 rows=30 width=512)
--         ->  Index Scan using idx_case_studies_featured on case_studies cs
--         ->  Index Scan using industries_pkey on industries ind
```

**Optimization**: If "Seq Scan" appears, add index!

### Index Strategies

**Single-Column Index** (for filtering):
```sql
CREATE INDEX idx_case_studies_featured ON case_studies(featured);
-- Used for: WHERE featured = TRUE
```

**Composite Index** (for filtering + sorting):
```sql
CREATE INDEX idx_case_studies_featured_published 
  ON case_studies(featured, published_date DESC);
-- Used for: WHERE featured = TRUE ORDER BY published_date DESC
```

**Partial Index** (for specific conditions):
```sql
CREATE INDEX idx_case_studies_published 
  ON case_studies(published_date DESC) 
  WHERE published_at IS NOT NULL;
-- Only indexes published case studies (smaller, faster)
```

**Full-Text Search Index** (for content search):
```sql
-- Add tsvector column for full-text search
ALTER TABLE case_studies
  ADD COLUMN search_vector tsvector;

-- Update search vector on insert/update
UPDATE case_studies
  SET search_vector = to_tsvector('english', title || ' ' || summary || ' ' || content);

-- Create GIN index
CREATE INDEX idx_case_studies_search ON case_studies USING GIN(search_vector);

-- Query
SELECT * FROM case_studies
WHERE search_vector @@ to_tsquery('english', 'data & analytics');
```

---

## Data Seeding

### Development Seed Script

```typescript
// server/database/seeds/index.ts
import { Strapi } from '@strapi/strapi'

export async function seed(strapi: Strapi) {
  console.log('ðŸŒ± Seeding database...')
  
  // 1. Seed industries (taxonomy)
  const industries = await seedIndustries(strapi)
  
  // 2. Seed tags
  const tags = await seedTags(strapi)
  
  // 3. Seed case studies (with relations)
  await seedCaseStudies(strapi, industries, tags)
  
  // 4. Seed insights (blog posts)
  await seedInsights(strapi, tags)
  
  console.log('âœ… Database seeded successfully')
}

async function seedIndustries(strapi: Strapi) {
  const industriesData = [
    { name: 'Healthcare', slug: 'healthcare', description: 'Healthcare & medical...' },
    { name: 'Finance', slug: 'finance', description: 'Financial services...' },
    { name: 'Retail', slug: 'retail', description: 'Retail & e-commerce...' },
  ]
  
  const industries = []
  for (const data of industriesData) {
    const industry = await strapi.entityService.create(
      'api::industry.industry',
      { data }
    )
    industries.push(industry)
  }
  
  return industries
}

async function seedCaseStudies(strapi: Strapi, industries, tags) {
  const caseStudiesData = [
    {
      title: 'Healthcare Analytics Platform',
      slug: 'healthcare-analytics',
      summary: 'Built a real-time analytics dashboard...',
      content: '...',
      industry: industries.find(i => i.slug === 'healthcare').id,
      tags: [tags[0].id, tags[1].id],
      publishedDate: '2024-01-15',
      featured: true,
    },
    // ... more case studies
  ]
  
  for (const data of caseStudiesData) {
    await strapi.entityService.create(
      'api::case-study.case-study',
      {
        data,
        files: {
          featuredImage: uploadedImage.id, // Pre-uploaded image
        },
      }
    )
  }
}
```

**Run Seed Script**:
```bash
cd server
yarn strapi seed
```

---

## Database Backup & Restore

### PostgreSQL Backup (Production)
```bash
# Full database backup
pg_dump -h localhost -U adc_user -d adc_production -F c -f backup_$(date +%Y%m%d).dump

# Backup specific tables
pg_dump -h localhost -U adc_user -d adc_production -t case_studies -F c -f case_studies_backup.dump

# Scheduled backup (cron)
# Daily at 2 AM
0 2 * * * /usr/bin/pg_dump -h localhost -U adc_user -d adc_production -F c -f /backups/adc_$(date +\%Y\%m\%d).dump
```

### PostgreSQL Restore
```bash
# Restore full database
pg_restore -h localhost -U adc_user -d adc_production -c backup_20250118.dump

# Restore specific tables
pg_restore -h localhost -U adc_user -d adc_production -t case_studies case_studies_backup.dump
```

### SQLite Backup (Development)
```bash
# Copy database file
cp server/.tmp/data.db server/.tmp/data_backup_$(date +%Y%m%d).db

# Dump SQL
sqlite3 server/.tmp/data.db .dump > backup.sql

# Restore from SQL
sqlite3 server/.tmp/data_new.db < backup.sql
```

---

## Data Integrity & Constraints

### Unique Constraints
```sql
-- Ensure slugs are unique (Strapi handles this)
ALTER TABLE case_studies
  ADD CONSTRAINT case_studies_slug_unique UNIQUE (slug);
```

### Check Constraints
```sql
-- Ensure published_date is not in the future
ALTER TABLE case_studies
  ADD CONSTRAINT case_studies_published_date_check
  CHECK (published_date <= CURRENT_DATE);
```

### Foreign Key Constraints
```sql
-- Cascade delete (if industry deleted, set case_studies.industry_id to NULL)
ALTER TABLE case_studies
  ADD CONSTRAINT fk_case_studies_industry
  FOREIGN KEY (industry_id) REFERENCES industries(id)
  ON DELETE SET NULL;
```

### Validation in Strapi
```typescript
// server/src/api/case-study/content-types/case-study/schema.json
{
  "attributes": {
    "title": {
      "type": "string",
      "required": true,
      "minLength": 5,
      "maxLength": 255
    },
    "slug": {
      "type": "uid",
      "targetField": "title",
      "required": true,
      "unique": true
    },
    "publishedDate": {
      "type": "date",
      "validate": (value) => {
        if (new Date(value) > new Date()) {
          throw new Error('Published date cannot be in the future')
        }
      }
    }
  }
}
```

---

## Monitoring & Alerts

### Query Performance Monitoring
```sql
-- PostgreSQL: Enable pg_stat_statements
CREATE EXTENSION pg_stat_statements;

-- View slowest queries
SELECT
  query,
  calls,
  total_time / 1000 AS total_seconds,
  mean_time / 1000 AS mean_seconds,
  max_time / 1000 AS max_seconds
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 20;
```

### Database Size Monitoring
```sql
-- Check database size
SELECT pg_size_pretty(pg_database_size('adc_production'));

-- Check table sizes
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname || '.' || tablename)) AS size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname || '.' || tablename) DESC;
```

### Connection Monitoring
```sql
-- Check active connections
SELECT
  datname,
  count(*) AS connections
FROM pg_stat_activity
GROUP BY datname;

-- Check long-running queries
SELECT
  pid,
  now() - query_start AS duration,
  query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '5 seconds'
ORDER BY duration DESC;
```

---

## Collaboration Points

### With Backend Specialist
- **Input**: Content type schemas, relationship requirements
- **Output**: Optimized database design, index recommendations
- **Sync**: Weekly schema review

### With DevOps Specialist
- **Input**: Production database setup, backup requirements
- **Output**: Migration scripts, backup strategies
- **Sync**: Bi-weekly infrastructure review

### With Lead Architect
- **Input**: Architecture decisions, data modeling standards
- **Output**: Database architecture documentation
- **Sync**: Monthly architecture review

---

## Key Deliverables

### 1. Database Schema Documentation
**File**: `docs/DATABASE_SCHEMA.md`
- Entity-relationship diagram (ERD)
- Table definitions with column types
- Index documentation
- Relationship descriptions

### 2. Migration Scripts
**Folder**: `server/database/migrations/`
- Schema migrations (versioned)
- Data migrations (backfilling, transformations)
- Rollback scripts

### 3. Seed Scripts
**Folder**: `server/database/seeds/`
- Development seed data
- Staging seed data
- Test fixtures

### 4. Performance Report
**File**: `docs/DATABASE_PERFORMANCE.md`
- Slow query analysis
- Index effectiveness
- Query optimization recommendations

---

## Common Issues & Solutions

### Issue 1: Slow Query (N+1)
**Symptom**: API response > 1 second  
**Solution**: Use `populate` to eager load relations

### Issue 2: Missing Index
**Symptom**: Query plan shows "Seq Scan"  
**Solution**: Add index on filtered/sorted columns

### Issue 3: Database Connection Pool Exhausted
**Symptom**: "too many connections" error  
**Solution**: Configure connection pooling in `server/config/database.ts`
```typescript
{
  connection: {
    pool: {
      min: 2,
      max: 10,
    },
  },
}
```

### Issue 4: Migration Failed
**Symptom**: Schema out of sync with code  
**Solution**: Delete `.tmp/` folder (dev) or run manual migration (prod)

---

## Success Metrics

### Performance
- **Query response time**: â‰¤ 50ms (95th percentile)
- **N+1 queries**: Zero detected
- **Index hit rate**: â‰¥ 95%

### Data Integrity
- **Schema violations**: Zero
- **Data loss incidents**: Zero
- **Backup success rate**: 100%

### Monitoring
- **Slow query alerts**: < 5 per day
- **Connection pool saturation**: Never
- **Database size growth**: Monitored monthly

---

**Status**: Active  
**Last Updated**: 2025-11-18  
**Contact**: Database Specialist Agent
